
//          Copyright Jason Boer 2015.
// Distributed under the Boost Software License, Version 1.0.
//
// Boost Software License - Version 1.0 - August 17th, 2003
// 
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license(the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third - parties to whom the Software is furnished to
// do so, all subject to the following :
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine - executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON - INFRINGEMENT.IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include <cstdio>
#include <thread>
#include <chrono>
#include <cinttypes>
#include <vector>
#include <cassert>

// windows.h will be used if include first else local function declarations will be used
#if 0
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#endif

// settings

// uncomment when using pthreads if the compiler doesn't support __thread currently set to 1 on OSX by default
//#define TLS_USE_PTHREAD_TLS_ 0
//#define TLS_USE_PTHREAD_TLS_ 1

// uncomment to enable asserts and the tls::debug() info function
//#define TLS_DEBUG_ 1

// uncomment to override build in assert with system assert or replace with custom assert
//#define TLS_ASSERT_(x) assert(x)

// this must be define in one and only file in a project per DATA type
#define TLS_IMPLEMENT_ 1

#include "ThreadLocalStorage.h"

// define your data it will be default constructed before first use
// this will be the _data member return from tls::acquire() and the
// tls::thread_exit() and tls::thread_enter() callbacks
struct tls_data_t {
	int * ptr;
	tls_data_t() : ptr(nullptr) {}
};

//if you know the maximum number of threads expected set it in the using statement - default is 1024
//template <typename DATA, uint32_t MAX_THREADS = 1024>
using tls = TLS::BASE<tls_data_t>;

static void test(size_t)
{
	for (size_t i = 0; i < 16; ++i) {

		// get the tls data for this thread
		auto & data = tls::acquire();

		assert(data._data.ptr != nullptr);
		printf("t:%" PRIxPTR" %p\n", data._id, data._data.ptr);
		std::this_thread::sleep_for(std::chrono::milliseconds(10));
	}

	// tls::thread_id() will match data._id
	printf("t:%" PRIxPTR"\n", tls::thread_id()); //-V576
}

int main(int argc, char ** argv)
{
	(void)argv;
	(void)argc;

#ifdef TLS_DEBUG_
	tls::debug();
#endif

	auto thread_exit = [](tls::data_t & data) {
		assert(data._data.ptr != nullptr);
		printf("exit:%" PRIxPTR" %p\n", data._id, data._data.ptr);
		delete data._data.ptr;
		data._data.ptr = nullptr;
	};

	// tls::thread_exit() will be call once per thread when it exits - the calling thread will not be the acquire thread
	// try not to do heavy lifting in the callback as it could cause performance problems
	tls::thread_exit(thread_exit);

	auto thread_enter = [](tls::data_t & data) {
		assert(data._data.ptr == nullptr);
		printf("enter:%" PRIxPTR" %p\n", data._id, data._data.ptr);
		data._data.ptr = new int;
	};

	// tls::thread_enter() will be call on the first tls::acquire() once per thread - calling thread will be the aquire thread
	tls::thread_enter(thread_enter);

	static const size_t n_threads = std::thread::hardware_concurrency() * 5;
//	static const size_t n_threads = 1024;
	static std::vector<std::thread> threads(n_threads);

	for (size_t i = 0; i < threads.size(); ++i) {
		threads[i] = std::thread([&] { test(i); });
	}

	for (size_t i = 0; i < threads.size(); ++i) {
		threads[i].join();
	}

	printf("n_threads: %u\n", (uint32_t)n_threads);

	return 0;
}

// clang++ -Wall -std=c++11 -g example.cpp -l pthread
// g++ -Wall -std=c++11 -g example.cpp -l pthread

